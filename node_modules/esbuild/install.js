var __assign = Object.assign;
var __async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (result) => {
      return result.done ? resolve(result.value) : Promise.resolve(result.value).then(fulfilled, rejected);
    };
    step((generator = generator.apply(__this, __arguments)).next());
  });
};
const fs = require("fs");
const os = require("os");
const url = require("url");
const path = require("path");
const zlib = require("zlib");
const https = require("https");
const version = require("./package.json").version;
const binPath = path.join(__dirname, "bin", "esbuild");
const stampPath = path.join(__dirname, "stamp.txt");
function installBinaryFromPackage(name, fromPath, toPath) {
  return __async(this, [], function* () {
    if (fs.existsSync(stampPath)) {
      return;
    }
    let officialRegistry = "registry.npmjs.org";
    let urls = [`https://${officialRegistry}/${name}/-/${name}-${version}.tgz`];
    let debug = false;
    try {
      let env = url.parse(process.env.npm_config_registry || "");
      if (env.protocol && env.host && env.pathname && env.host !== officialRegistry) {
        let query = url.format(__assign(__assign({}, env), {pathname: path.posix.join(env.pathname, `${name}/${version}`)}));
        try {
          let tarball = JSON.parse((yield fetch(query)).toString()).dist.tarball;
          if (urls.indexOf(tarball) < 0)
            urls.unshift(tarball);
        } catch (err) {
          console.error(`Failed to download ${JSON.stringify(query)}: ${err && err.message || err}`);
          debug = true;
        }
      }
    } catch (e) {
    }
    for (let url2 of urls) {
      let tryText = `Trying to download ${JSON.stringify(url2)}`;
      if (debug)
        console.error(tryText);
      try {
        let buffer = extractFileFromTarGzip(yield fetch(url2), fromPath);
        if (debug)
          console.error(`Install successful`);
        fs.writeFileSync(toPath, buffer);
        fs.writeFileSync(stampPath, "");
        return;
      } catch (err) {
        if (!debug)
          console.error(tryText);
        console.error(`Failed to download ${JSON.stringify(url2)}: ${err && err.message || err}`);
        debug = true;
      }
    }
    console.error(`Install unsuccessful`);
    process.exit(1);
  });
}
function fetch(url2) {
  return new Promise((resolve, reject) => {
    https.get(url2, (res) => {
      if ((res.statusCode === 301 || res.statusCode === 302) && res.headers.location)
        return fetch(res.headers.location).then(resolve, reject);
      if (res.statusCode !== 200)
        return reject(new Error(`Server responded with ${res.statusCode}`));
      let chunks = [];
      res.on("data", (chunk) => chunks.push(chunk));
      res.on("end", () => resolve(Buffer.concat(chunks)));
    }).on("error", reject);
  });
}
function extractFileFromTarGzip(buffer, file) {
  try {
    buffer = zlib.unzipSync(buffer);
  } catch (err) {
    throw new Error(`Invalid gzip data in archive: ${err && err.message || err}`);
  }
  let str = (i, n) => String.fromCharCode(...buffer.subarray(i, i + n)).replace(/\0.*$/, "");
  let offset = 0;
  while (offset < buffer.length) {
    let name = str(offset, 100);
    let size = parseInt(str(offset + 124, 12), 8);
    offset += 512;
    if (!isNaN(size)) {
      if (name === file)
        return buffer.subarray(offset, offset + size);
      offset += size + 511 & ~511;
    }
  }
  throw new Error(`Could not find ${JSON.stringify(file)} in archive`);
}
function installOnUnix(name) {
  if (process.env.ESBUILD_BIN_PATH_FOR_TESTS) {
    fs.unlinkSync(binPath);
    fs.symlinkSync(process.env.ESBUILD_BIN_PATH_FOR_TESTS, binPath);
  } else {
    installBinaryFromPackage(name, "package/bin/esbuild", binPath).catch((e) => setImmediate(() => {
      throw e;
    }));
  }
}
function installOnWindows(name) {
  fs.writeFileSync(binPath, `#!/usr/bin/env node
const path = require('path');
const esbuild_exe = path.join(__dirname, '..', 'esbuild.exe');
const child_process = require('child_process');
child_process.spawnSync(esbuild_exe, process.argv.slice(2), { stdio: 'inherit' });
`);
  const exePath = path.join(__dirname, "esbuild.exe");
  if (process.env.ESBUILD_BIN_PATH_FOR_TESTS) {
    fs.copyFileSync(process.env.ESBUILD_BIN_PATH_FOR_TESTS, exePath);
  } else {
    installBinaryFromPackage(name, "package/esbuild.exe", exePath).catch((e) => setImmediate(() => {
      throw e;
    }));
  }
}
const key = `${process.platform} ${os.arch()} ${os.endianness()}`;
const knownWindowsPackages = {
  "win32 ia32 LE": "esbuild-windows-32",
  "win32 x64 LE": "esbuild-windows-64"
};
const knownUnixlikePackages = {
  "darwin x64 LE": "esbuild-darwin-64",
  "freebsd arm64 LE": "esbuild-freebsd-arm64",
  "freebsd x64 LE": "esbuild-freebsd-64",
  "linux arm64 LE": "esbuild-linux-arm64",
  "linux ia32 LE": "esbuild-linux-32",
  "linux ppc64 LE": "esbuild-linux-ppc64le",
  "linux x64 LE": "esbuild-linux-64"
};
if (key in knownWindowsPackages) {
  installOnWindows(knownWindowsPackages[key]);
} else if (key in knownUnixlikePackages) {
  installOnUnix(knownUnixlikePackages[key]);
} else {
  console.error(`Unsupported platform: ${key}`);
  process.exit(1);
}
